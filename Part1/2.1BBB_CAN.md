#### 使能BBB的CAN总线

* ##### 了解Linux设备树

device tree是linux 3.x开始使用的加载硬件资源的方式，这里说的硬件资源既包括片上的诸如GPIO、PWM、I2C、ADC等资源，也包括外部拓展的如FLASH、LCD等。device tree主要作用是将某个硬件外设与相应的驱动程序进行绑定。使用时首先需要编写一个`.dts`文件（device tree source），在文件中说明我要设置的硬件和它的各种属性，然后编译这个`.dts`文件生成对应的二进制文件`.dtb`，系统启动时就会加载这个device tree并配置各种硬件资源。
  在BBB的`/lib/firmware`目录下，你可以看到很多DTS文件，我们打开我们之后要用到的CAN总线驱动`BB-CAN1-01-00A0.dts`看看它长什么样：

```
/*
* Copyright (C) 2013 Martin Gysel <me@bearsh.org>
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 as
* published by the Free Software Foundation.
*/
/dts-v1/;
/plugin/;


/ {
	compatible = "ti,beaglebone", "ti,beaglebone-black";
	part-number = "DVK551-CAN1-01";
	version = "00A0";

	/* state the resources this cape uses */
	exclusive-use =
		/* the pin header uses */
		"P9.24",		/* dcan1: dcan1_rx */
		"P9.26",		/* dcan1: dcan1_tx */
		/* the hardware IP uses */
		"dcan1";

	fragment@0 {
		target = <&am33xx_pinmux>;
		__overlay__ {
			bone_serl_01_dcan1_pins: bone_serl_01_dcan1_pins {
				pinctrl-single,pins = <
					0x180 0x02      /* uart1_rxd.d_can1_tx", OUTPUT | MODE2 */
					0x184 0x32      /* uart1_txd.d_can1_rx", INPUT_PULLUP | MODE2 */
				>;
			};
		};
	};

	fragment@1 {
		target = <&dcan1>;
		__overlay__ {
			status = "okay";
			pinctrl-names = "default";
			pinctrl-0 = <&bone_serl_01_dcan1_pins>;
		};
	};
};


```

可以看到，`.dts`文件是一个树形结构，是由若干节点和属性组成的`compatible =“ti，beaglebone”`，`“ti，beaglebone-black”`; 这行代码上面相邻行的斜杠`/`代表根节点，下面的片段`@0`和片段`@1`是其两个子节点。其中根节点下面的属性声明了本DTS文件适用的平台，它的名字，版本号，使用了哪些引脚和硬件资源等.`fragment@0`节点中配置了两个BBB引脚的功能，把它们设置成了UART1的TX和RX功能.`fragment@1`节点中使能了`can1`这个硬件设备（启用了相应的驱动）。

这几行代码是用来配置引脚功能的：
```
pinctrl-single,pins = <
0x180 0x02      /* uart1_rxd.d_can1_tx", OUTPUT | MODE2 */
0x184 0x32      /* uart1_txd.d_can1_rx", INPUT_PULLUP | MODE2 */
```
其中第一列的量`0x180`和量`0x184`分别是P9.26和P9.24的地址，第二列的`0X02`代表要配置成什么功能。它们都是怎么确定的呢？P9.24所在的行然后在第三列中可以看到它的偏移地址(OFFSET)是`0x184`。

如何查看BBB当前的引脚功能呢？  
`cat /sys/kernel/debug/pinctrl/44e10800.pinmux/pins`

因为这个目录很常用，我把它存成了环境变量`$ PINS`以后我使用`cat $ PINS`就可以了。  

另外一个要注意的是每个DTS里根节点下都有这两个属性：  
`part-number ="BB-UART1;"  `
`version ="00A0";`

第一个是名字，第二个是版本号。你自己写的DTS文件要新起一个名字，版本号则必须按照`00A0`,`00A1` ......这样的顺序依次排下去。你的DTS文件名必须是“名字+版本号`.dts”`的格式，如这里的`BB-CAN1-01-00A0.dts`。

三，编译DTS文件

写好DTS文件以后，要把它转化成系统可识别的格式。上面说到有DTB和dtbo两种格式，我们这里要转化成的是dtbo格式。因为BBB的埃系统在上电启动的时候就加载了一个DTB文件，给每个引脚配置了默认的功能，加载了需要加载的驱动程序。因为这个DTB文件已经加载，我们在系统运行着的情况下是不能修改它的。我们能做的，是在系统这个DTB的基础上，“叠加（重叠）”一些新的功能，因此要用dtbo（DTB叠加）格式。

实际上，DTS和dtbo文件可以随时编译和反编译，即DTS可以生成dtbo，dtbo也可以复原成DTS（但是复原的DTS里没有注释等无用的东 了）编译和反编译使用的命令都是相同的：。DTC（设备树编译）  
DTS编译成dtbo：  
dtc -I dts -O dtb - @ BB-UART1-00A0.dts&gt; BB-UART1-00A0.dtbo

dtbo反编译成DTS：  
dtc -I dtb -O dts BB-UART1-00A0.dtbo&gt; BB-UART1-00A0.dts

（注：有的网站上编译用的是这样的命令：dtc -O dtb -o BB-UART1-00A0.dtbo -b 0 - @ BB-UART1-00A0.dts，其实都一样啦。我觉得上面给出现的写法更好记一点。）

四，加载dtbo文件

加载之前，一定记住要把编译好的dtbo文件放到/ lib / firmare /目录中，否则程序是找不到你的dtbo文件的

。Beaglebone黑中用一个叫做斗篷经理的软件管理所有的斗篷，不论它是实实在在的扩展板，还是虚拟的斗篷。这个软件的目录是  
/sys/devices/bone\_capemgr.8/（这里的数字也有可能是9，与启动顺序有关，你可以直接用\*代替它）。这个目录内有一个叫做槽的文件，这就是capemgr这个软件的对外接口。我们要加载某个斗篷的话，只需要向这个文件中写入DTS文件里定义的名字（部分数属性）即可：  
回显BB-UART1&gt; /sys/devices/bone\_capemgr.8/slots

槽这个单词是“插槽”的意思，看，很形象吧！我要插上一个斗篷，就向这个“插槽”里“插入”（回波）相应的设备.echo这个命令的含义是“向标准设备输出“嘛。因为这个目录很常用，所以我把它存成环境变量$ SLOTS，这样以后只需写echo BB-UART1&gt; $ SLOTS即可了。

（注：如果那个dtbo有多个版本，比如有00A0,00A1,00A2这3个版本，如果你只写echo BB-UART1&gt; $ SLOTS的话，它会自动加载最新的版本。而且，必须保证从00A0开始每个版本都存在才可以成功加载，就是说，如果/ lib中/固件/目录中只有00A2这一个版本的话，加载会失败但是，你可以通过回声BB-UART1：。00A2&gt; $角子机像这样添加版本号来加载某个特定版本）

五，查看和卸载已加载的斗篷

使用命令：  
猫$时尚

。可以查看当前已经加载的所有斗篷比如在我的BBB上执行命令后得到输出：  
root @ beaglebone：〜＃cat $ SLOTS  
0：54：P --- L Beaglebone LCD4角，00A1，BeagleboardToys，BB-BONE-LCD4-01  
1：55：PF ---  
2：56：PF ---  
3：57：PF ---  
4：ff：POL Bone-LT-eMMC-2G，00A0，德州仪器，BB-BONE-EMMC-2G  
7：ff：POL覆盖板名称，00A0，Override Manuf，BB-ADC  
8：ff：POL覆盖板名称，00A0，Override Manuf，BB-UART1

前面说了slots是“插槽”的意思，可以看到我这里已经“插入”了4个cape，包括1个实体的LCD cape和3个虚拟cape

BBB可以插入4个实体cape，它们只能插在0,1,2,3这四个时隙里，这也是1,2,3号时隙是空白的原因。后面的时隙里都是虚拟斗篷，只要引脚不冲突，可以不限数量地添加。一旦你的dtbo文件使用的引脚与已加载的斗篷有冲突，就会提示：  
-sh：echo：写入错误：文件存在

另外注意上面显示的几个已加载的斗篷里的这部分内容。“FF：POL”，这里最后的“L”代表这个斗篷已经被加载，即已经启用也许你将来会遇到虽然显示在$角子机里，但是没有这个“L”的斗篷，那样的话它基本等于不存在。

至于卸载斗篷，假设我要卸载我的第8个斗篷，按照官方的说法，应当这样操作：  
回声-8&gt; $时隙

但因为系统bug的原因，这样操作会导致系统重启......所以目前只能通过重启系统来卸载cape。等出系统更新也许就解决这个bug了。

